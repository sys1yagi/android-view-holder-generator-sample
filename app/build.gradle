apply plugin: 'android'

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.1"

    defaultConfig {
        minSdkVersion 7
        targetSdkVersion 19
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
            runProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

dependencies {
    compile 'com.android.support:appcompat-v7:+'
}

import com.sun.codemodel.*
import groovy.xml.*

String camerize(String snakeCased) {
    def first = snakeCased.substring(0, 1)
    def rest = snakeCased.substring(1)
    return first.toUpperCase() + rest.toLowerCase()
}

String qualifyViewClassName(String name) {
    if (name.contains(".")) { // already fully-qualified
        return name
    }
    else if (name == "View") {
        return "anndroid.view.$name"
    }
    else {
        return "android.widget.$name"
    }
}

ext.generateViewHolders = { xmlFiles ->
    def manifestXml = new XmlSlurper().parse(file("src/main/AndroidManifest.xml"))

    def pkg = manifestXml.'@package'.toString()
    xmlFiles.each { File layoutXml ->
        def simpleName = layoutXml.getName().split('\\.')[0]
        def className = simpleName.split('_').collect { String part ->
            camerize(part)
        }.join('') + "ViewHolder"
        println("Generating ${className}.java from $layoutXml")

        def model = new JCodeModel()
        def vhClass = model._class(pkg + ".generated.viewholder.$className")

        def androidNs = new Namespace("http://schemas.android.com/apk/res/android",
                "android")
        def xmlParser = new XmlParser()
        def layout = xmlParser.parse(layoutXml)

        vhClass.field(JMod.PUBLIC, model.ref(qualifyViewClassName(layout.name())), "view")

        // ViewHolder.from(Context context, View rootView)
        JMethod fromMethod = vhClass.method(JMod.STATIC | JMod.PUBLIC, vhClass, "from")
        JVar context = fromMethod.param(model.ref("android.content.Context"), "context")
        JVar rootView = fromMethod.param(model.ref("android.view.ViewGroup"), "rootView")

        JBlock block = fromMethod.body();
        JVar holder = block.decl(vhClass, "holder", JExpr._new(vhClass))

        JFieldRef resId = model.ref("${pkg}.R.layout").staticRef(simpleName)
        JInvocation inflateExpr = model.ref("android.view.View").staticInvoke("inflate").arg(context).arg(resId).arg(rootView)
        JVar view = block.decl(model.ref("android.view.View"), "view", inflateExpr)

        Closure<Void> walk
        walk = { Node element ->
            def widgetId = element.attribute(androidNs.get("id"))
            if (widgetId != null) {
                def parts = widgetId.split('/') // like '@id+/name'
                def id = parts[1]

                JClass type = model.ref(qualifyViewClassName(element.name()))
                vhClass.field(JMod.PUBLIC, type, id)

                // holder = (T)findViewById
                block.assign(holder.ref(id),
                        JExpr.cast(type,
                        view.invoke("findViewById").
                                arg(model.ref(pkg + ".R.id").staticRef(id))))

            }

            element.children().each { walk(it) }
        }

        walk(layout)

        block._return(holder);

        def javaSourceDir = file("src/main/java")
        javaSourceDir.mkdirs()
        model.build(javaSourceDir)
    }
}

preBuild.dependsOn(task("generateViewHolders") << {
    generateViewHolders(fileTree(dir: "src/main", include: "res/layout/*.xml"))
})
